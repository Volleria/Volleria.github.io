{"meta":{"title":"Volleria 个人博客","subtitle":"","description":"","author":"EKKO","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-07-27T09:43:03.000Z","updated":"2022-07-27T09:43:03.263Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-27T10:05:46.000Z","updated":"2022-07-27T10:05:46.774Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-27T10:05:32.000Z","updated":"2022-07-27T10:05:32.443Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络爬虫","slug":"计算机网络实验","date":"2022-07-27T09:47:18.113Z","updated":"2022-07-27T11:20:56.079Z","comments":true,"path":"2022/07/27/计算机网络实验/","link":"","permalink":"http://example.com/2022/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/","excerpt":"一、基本信息（略） 二、实验目的要求学生掌握Socket编程技术及令牌总线协议工作过程 $$&#x2F;$$","text":"一、基本信息（略） 二、实验目的要求学生掌握Socket编程技术及令牌总线协议工作过程 $$&#x2F;$$ 三、基础实验内容Ⅰ、traceroute1、实验目的：熟悉traceroute的使用 2、实验内容： 用traceroute测量到163网站（www.163.com）和到微软公司（www.microsoft.com）网站的路径。分析测量结果。 3、实验流程及结果 在Ubuntu上下载安装traceroute 用traceroute测量到163网站（www.163.com）的路径 用traceroute测量到微软网站（www.microsoft.com）的路径 上述输出信息显示了跟踪到的路由地址信息。记录从序号 1 开始，每个记录就是一跳，而每一跳表示经过的一个网关。记录给出了每个网关对应的IP地址。其中，为 *** 的记录表示可能被防火墙拦截的 ICMP 的返回信息。 在linux上使用traceroute，默认使用udp协议，除了第一跳，剩下的都是* * *。是因为虚拟机 nat 路由器，默认丢弃port&gt;32767的包。在命令中加入 -l 强制使用ICMP得到上图结果。 Ⅱ、wireshark1、实验目的：熟悉wireshark的使用 2、实验内容：下载安装wireshark软件，设置捕获条件，用wireshark捕获数据包，对以太网帧和IP数据包进行分析。 3、实验流程及结果 Wireshark 是一个免费开源的网络数据包分析软件。它的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。 下载安装Wireshark并启动 查询网卡 打开火绒浏览器开始发包测试 TCP找目的地址，捕获数据包，对以太网帧和IP数据包进行分析。 将 TCP 80 端口 作为过滤条件进行筛选分析 四、工程性实验内容Ⅰ、Robots协议具体内容：查看淘宝网的Robots协议，了解抓取网站数据需要遵循的规则 Robots协议的全称是“网络爬虫排除标准”(Robots Exclusion Protocol)，网站通过Robots协议告诉搜索引擎哪些页面可以爬取，哪些页面不可以爬取。这个协议是互联网中的道德规范，虽没写入法律，但应遵守。在网站末尾加/robots.txt可以进行查看。 Robots协议的语法：#注释，*代表所有，&#x2F;代表根目录。 无robots协议的网站，信息可以爬取。 自动或人工识别robots.txt，再进行内容爬取，Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险。访问量很小的可以遵循，访问量大的建议遵循。非商业的建议遵循，涉及商业利益的必须遵循，爬取全网信息必须要遵循。如果是类似人类行为的爬取信息，可不遵循。 Ⅱ、 搜索关键词查询确定其关键词的查询接口以豆瓣图书为例，进入豆瓣读书网站 随便点击一本书，观察其网址 观察到红框部分即为该书在豆瓣数据库中的代号 进入短评部分 观察到前一个红框部分为该书的代码，后一个红框部分为这一页短评的起始标号，豆瓣书籍网页版一页共有20条短评，所以 start &#x3D; num （num从0开始并且为20的整倍数） 1234url = &quot;https://book.douban.com/subject/&#123;&#125;/comments/?start=&#123;&#125;&amp;limit=20&amp;status=P&amp;sort=new_score&quot;# booknum和index分别为书籍代码和start起始下标u = url.format(str(booknum),str(index)) 所以之后对豆瓣图书评论的查询靠替换关键字完成 Ⅲ、爬取豆瓣图书评论具体内容抓取豆瓣读书中对某本书的前50条短评内容并计算星级评定分数的平均值（保留两位小数） 实验步骤TCP协议：传输控制协议（Transmission Control Protocol，缩写为TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，它能提供高可靠性通信(即数据无误、数据无丢失、数据无失序、数据无重复到达的通信)。 主要适用的场景： 适合于对传输质量要求较高，以及传输大量数据的通信。 在需要可靠数据传输的场合，通常使用TCP协议。 HTTP&#x2F;HTTPS等即网络服务都采用TCP协议。 TCP通信需要经过创建连接、数据传送、终止连接三个步骤。 初始化 url ，并通过 get() 函数逐网页爬取网页源代码 12345url = &quot;https://book.douban.com/subject/&#123;&#125;/comments/?start=&#123;&#125;&amp;limit=20&amp;status=P&amp;sort=new_score&quot;for index in range(0, 60, 20): # booknum 为豆瓣书籍编号，本实验选用的是35593780 u = url.format(str(booknum),str(index)) r = get(u) 创建 socket 实例，处理 https 的库 1234def get(url): host = &#x27;book.douban.com&#x27; path = url[23:] s = ssl.wrap_socket(socket.socket()) 初始化端口，与主机建立起连接 12port = 443 # 端口 https 默认端口443s.connect((host, port)) # 建立起连接，连接主机 设置报文格式 12# 报文格式： GET+空格+com后面的部分+空格+HTTP/1.1(或1.0)+\\r\\n+Host:+域名+\\r\\n\\r\\nrequest = &#x27;GET &#123;&#125; HTTP/1.1\\r\\nHost: &#123;&#125;\\r\\n\\r\\n&#x27;.format(path, host) # 构建请求 发送请求并接受数据 123456789s.send(request.encode(&#x27;utf-8&#x27;)) # 发送请求 转码，将str 转成bytes类型response = b&#x27;&#x27;while True: # 接受数据 r = s.recv(1024) response += r if len(r) &lt; 1024: breakresponse = response.decode(&#x27;utf-8&#x27;) # 解码 对数据进行查找分析 此处主要使用 str 类型所带的 find() 函数 Python find() 方法检测字符串中是否包含子字符串 str 如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 123456789# html 为字符串# userstart 为每个用户所在源代码的开始位置# userend 每个用户所在源代码的结束位置# start_str为所查询字符串的前部分# end_str为所查询字符串的后部分def getdata(html, userstart, userend, start_str, end_str): start = html.find(start_str, userstart, userend) end = html.find(end_str, start) return 0 if start == -1 else html[start + len(start_str):end] 对于星级的平均分计算，考虑到有些用户没有打分，计算平均分时需将其删除。对于上面的数据查询函数 getdata() ，如果未能查询到该用户所打的分数，则在star[] 数组中写入0，若查询到所打的分数，则写入该分数。 将结果进行整理输出 12# douban.txt 文件和当前py文件位于同一目录之下output = open(&quot;douban.txt&quot;,&#x27;w&#x27;,encoding=&#x27;UTF—8&#x27;) 将50条评论逐行输入至 douban.txt 文件中，在第51行输入平均分数，第52行输入书名。 可视化界面该可视化界面采用 Unity3D 制作，版本为 2021.2.7f1c1，所用语言为 C# 【展示】 [1] 处按钮为显示前页评论 [2] 处按钮为显示后页评论 [3] 处为书名显示区域 [4] 处为所求得的平均分数（保留两位小数） [5] [6] [7] [8] 处为评论内容显示区域，可上下拖拽查看全部内容 【代码及主要制作思路】 创建一个string类型的数组，用以存储评论、书名、分数等数据 1string[] txt 使用绝对路径读取上述 douban.txt 文件 12using System.IO;txt = File.ReadAllLines(&quot;C:\\\\Users\\\\EKKO\\\\Desktop\\\\ComputerNetwork\\\\CNLab\\\\douban.txt&quot;); 此时 txt 数组共有52个元素，存储50条评论、一个书名、一个平均分数 新建 TEXT 类型数组 comments 并与UI上的组件进行绑定，将书名和分数直接显示。 12345678comments[0] = transform.GetChild(7).GetComponent&lt;Text&gt;();comments[0].text = &quot;平均分数:&quot;+txt[50];comments[1] = transform.GetChild(1).GetChild(0).GetComponent&lt;Text&gt;();comments[2] = transform.GetChild(2).GetChild(0).GetComponent&lt;Text&gt;();comments[3] = transform.GetChild(3).GetChild(0).GetComponent&lt;Text&gt;();comments[4] = transform.GetChild(4).GetChild(0).GetComponent&lt;Text&gt;();bookname = transform.GetChild(9).GetComponent&lt;Text&gt;();bookname.text = &quot;《&quot;+txt[51] +&quot;》&quot;; 调用按钮点击相应事件，为 ‘前页’ ‘后页’ 按钮绑定相关操作 123456789101112131415upbtn.onClick.AddListener(setindexup);downbtn.onClick.AddListener(setindexdown);void setindexup()&#123; for (int i = 1;i &lt;5;i++) if(index[i] &lt; 49) index[i] += 4;&#125;void setindexdown()&#123; for (int i = 1;i &lt;5;i++) if(index[i] &gt; 4) index[i] -= 4;&#125; 最后在 Update() 函数中逐帧进行赋值操作，达到动态刷新的效果 12345678void Update()&#123; for(int i = 1;i &lt; 5 ;i++) if( index[i]-1 &gt; 49 ) comments[i].text = null; else comments[i].text = txt[index[i] - 1];&#125; Ⅳ、抓取道指成分股数据具体内容在https://money.cnn.com/data/dow30/ 上抓取道指成分股数据并解析其中30家公司的代码、名称和最近一次成交价，将结果放到一个列表中输出。 实验步骤采用 request 和 re 两个包来解决 12import requestsimport re 确定查询网址路径 1url = &#x27;https://money.cnn.com/data/dow30/&#x27; 由于网址发生变化，所以实际进入的网址为 通过r&#x3D;request.get（url）构造一个向服务器请求资源的url对象。 这个对象是Request库内部生成的。 这时候的r返回的是一个包含服务器资源的Response对象。包含从服务器返回的所有的相关资源。 1r = requests.get(url) 根据网页源代码，构建查匹配对应数据所需的正则表达式 12pattern = re.compile( &#x27;wsod_symbol&quot;&gt;(.*?)&lt;/a&gt; &lt;span title=&quot;(.*?)&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;td class=&quot;wsod_aRight&quot;&gt;&lt;span stream=&quot;last_(.*?)&lt;&#x27;) 进行匹配查询 12# data 为一个含有4个元素的元组，包含所需数据data = re.findall(pattern, r.text) 数据处理：对数据进行筛选比对，选取所需要的 【公司的代码】、【名称】、【最近一次成交价】 12345for i in data: # print(&quot;i:&quot;,i) m = (i[0], i[1], i[3][-6:]) # 将其添加到列表中 dowdata.append(m) 输出示例： 12for i in dowdata: print(i) 该结果对应时间：2022.4.28 -17:41","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"简单水墨风格Shader","slug":"水墨风格shader","date":"2022-07-27T09:47:18.100Z","updated":"2022-07-26T03:54:57.825Z","comments":true,"path":"2022/07/27/水墨风格shader/","link":"","permalink":"http://example.com/2022/07/27/%E6%B0%B4%E5%A2%A8%E9%A3%8E%E6%A0%BCshader/","excerpt":"效果图","text":"效果图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 需要一个MainTex主纹理贴图、一个水墨笔刷贴图Shader &quot;Unlit/shuimo&quot;&#123; Properties &#123; _MainTex(&quot;Main&quot;, 2D) = &quot;white&quot; &#123;&#125; _Thred(&quot;Edge Thred&quot; , Range(0.01,1)) = 0.25 _Range(&quot;Edge Range&quot; , Range(0,5)) = 1 _Pow(&quot;Edge Intensity&quot;,Range(0,5))=1 _BrushTex(&quot;Brush Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; _Saturation(&quot;Saturation&quot; ,Range(0,1)) = 0 _BlenderRow(&quot;BlenderRow&quot;,Range(0,1)) = 0 [Enum(Opacity,1,Darken,2,Lighten,3,Multiply,4,Screen,5,Overlay,6,SoftLight,7)] _BlendType(&quot;Blend Type&quot;, Int) = 1 &#125; SubShader &#123; Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125; LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal : NORMAL; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; float3 worldPos : TEXCOORD1; float3 worldNormal : TEXCOORD2; &#125;; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BrushTex; float _BlendType; float _Thred; float _Range; float _Pow; float _Saturation; float _BlenderRow; v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz; o.worldNormal = UnityObjectToWorldNormal(v.normal); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; float3 ViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos); float NdotV = max( dot(ViewDir,i.worldNormal) , 0); fixed4 mainTex = tex2D(_MainTex, i.uv); fixed4 brushTex = tex2D(_BrushTex, i.uv); // fixed texGrey = (mainTex.r + mainTex.g + mainTex.b)*0.33; // 平均值法求灰度 // GrayScale=0.299*R+0.578*G+0.114*B 加权平均求灰度 fixed texGrey = 0.299 * mainTex.r + 0.578 * mainTex.g + 0.114 * mainTex.b; texGrey = pow(texGrey, 0.3); texGrey *= 1 - cos(texGrey * 3.14); fixed brushGrey = (brushTex.r + brushTex.g + brushTex.b)*0.33; fixed blend = texGrey * 0.5 + brushGrey * 0.5; fixed4 col = fixed4(blend, blend, blend, 1); fixed edge = pow(NdotV, 1) / _Range; edge = edge &gt; _Thred ? 1 : edge; edge = pow(edge, _Pow); fixed4 edgeColor = fixed4(edge, edge, edge, edge); col = edgeColor * (1 - edgeColor.a) + col * (edgeColor.a); fixed4 rowtex =tex2D(_MainTex,i.uv); //saturation饱和度：首先根据公式计算同等亮度情况下饱和度最低的值： fixed minGray = 0.2125 * rowtex.r + 0.7154 * rowtex.g + 0.0721 * rowtex.b; fixed3 mingrayColor = fixed3(minGray, minGray, minGray); //根据Saturation在饱和度最低的图像和原图之间差值 float3 RowColor = lerp(mingrayColor, rowtex.rgb, _Saturation); float3 blendrow = RowColor * (1 - _BlenderRow) + float3(brushGrey,brushGrey,brushGrey) * _BlenderRow; float3 finalColor = col * blendrow; return fixed4(finalColor,1); &#125; ENDCG &#125; &#125;&#125; 实现方法一、求灰度图对灰度图像的处理一般有以下四种方法: 1.分量法 该方法将彩色图像中的三分量的亮度作为三个灰度图像的灰度值，可根据应用需要选取一种灰度图像。即：可以选取RGB中的任一颜色通道作为灰度值。公式为：GrayScale1 &#x3D; R，GrayScale2 &#x3D; G，GrayScale3 &#x3D; B 2.最大值法 该方法将彩色图像中的三分量亮度的最大值作为灰度图的灰度值，一般的，该方法求取后的灰度图亮度最高。公式为：GrayScale &#x3D; max(R, G, B) 3.平均值法 该方法将彩色图像中的RGB三分量的颜色值来求取平均值作为灰度值。公式为：GrayScale &#x3D; (R+G+B) &#x2F; 3 4.加权平均法 该方法根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到相对合理的灰度图像。公式为：GrayScale &#x3D; 0.299 *R + 0.578 *G + 0.114 *B 此处对主纹理采用加权平均法、对水墨笔刷采用平均值法 二、利用混合公式混合颜色Texture和水墨笔触Texture图片混合的多种模式：https://www.cnblogs.com/kex1n/p/3663533.html 三、利用 VdotN 求边缘效果1234fixed edge = pow(NdotV, 1) / _Range;edge = edge &gt; _Thred ? 1 : edge;edge = pow(edge, _Pow);fixed4 edgeColor = fixed4(edge, edge, edge, edge); 四、降低原图饱和度，再将其与水墨笔刷进行混合 （可选项）1234567fixed4 rowtex =tex2D(_MainTex,i.uv);//saturation饱和度：首先根据公式计算同等亮度情况下饱和度最低的值：fixed minGray = 0.2125 * rowtex.r + 0.7154 * rowtex.g + 0.0721 * rowtex.b;fixed3 mingrayColor = fixed3(minGray, minGray, minGray);//根据Saturation在饱和度最低的图像和原图之间差值float3 RowColor = lerp(mingrayColor, rowtex.rgb, _Saturation);float3 blendrow = RowColor * (1 - _BlenderRow) + float3(brushGrey,brushGrey,brushGrey) * _BlenderRow;","categories":[{"name":"Shader学习","slug":"Shader学习","permalink":"http://example.com/categories/Shader%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"Shader","slug":"Shader","permalink":"http://example.com/tags/Shader/"}]},{"title":"暗通道去雾及两种超分算法的简单对比","slug":"暗通道去雾及两种超分算法的简单对比","date":"2022-07-27T09:47:18.098Z","updated":"2022-07-26T03:54:38.521Z","comments":true,"path":"2022/07/27/暗通道去雾及两种超分算法的简单对比/","link":"","permalink":"http://example.com/2022/07/27/%E6%9A%97%E9%80%9A%E9%81%93%E5%8E%BB%E9%9B%BE%E5%8F%8A%E4%B8%A4%E7%A7%8D%E8%B6%85%E5%88%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/","excerpt":"Ⅰ、暗通道先验图像去雾霾参考论文：K. He, J. Sun and X. Tang, “Single Image Haze Removal Using Dark Channel Prior,” in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 33, no. 12, pp. 2341-2353, Dec. 2011. 阅读地址：https://readpaper.com/pdf-annotate/note?noteId=696733953373192192&amp;pdfId=4531190175211610113","text":"Ⅰ、暗通道先验图像去雾霾参考论文：K. He, J. Sun and X. Tang, “Single Image Haze Removal Using Dark Channel Prior,” in IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 33, no. 12, pp. 2341-2353, Dec. 2011. 阅读地址：https://readpaper.com/pdf-annotate/note?noteId=696733953373192192&amp;pdfId=4531190175211610113 一、论文简介在本文中，作者提出了一种简单而有效的图像先验-暗通道，用于去除单个输入图像中的雾霾。暗通道先验是一种对室外无雾图像的统计。它是基于一个关键的观察-在室外无雾图像中的大多数局部斑块包含一些像素，其强度在至少一个彩色通道非常低。利用这一先验和烟雾成像模型，我们可以直接估计雾霾的厚度，并恢复一幅高质量的无雾霾图像。在各种模糊图像上的结果表明了所提出的先验方法的有效性。 二、具体过程介绍在计算机视觉领域，存在一个对于雾霾图像的模型定义：$$I(x)&#x3D; J(x)t(x) + A(1-t(x))$$其中 $I(x)$ 为我们实际可以观测到的亮度，也可以理解为带雾的原图，是一个已知的值 $J(x)$ 可以理解为去雾之后的结果图像 $t(x)$ 为透射率（transmission from scene to camera） $A$ 为全球大气光值（atmospheric light） 最终目标：从 $I$ 中恢复出 $J$ 、$A$ 和 $t$ 1、暗通道图像根据原文中的公式获取暗通道图像并进行腐蚀操作$$J^{dark}(x) &#x3D; \\underset {c\\in {r,g,b }}{min} \\ \\underset {y \\in \\Omega(x) }{(\\ min}\\ (J^c(y)))$$ 12345678910111213141516171819202122def DarkChannel(image, size): b, g, r = cv2.split(image) # 顺序是b,g,r，不是r,g,b min_channel = cv2.min(cv2.min(r, g), b) # 得到三通道中的最小值 # cv2.getStructuringElement() # 这个函数的第一个参数表示内核的形状，有三种形状可以选择。 # 腐蚀操作可以看做 将图像（或图像的一部分区域，我们称之为A）与核进行卷积 # 腐蚀（erosion） # 腐蚀就是原图中的高亮部分被腐蚀，效果图拥有比原图更小的高亮区域 # 膨胀和腐蚀的主要用途: # 1、消除噪声 # 2、分割出独立的图像元素，在图像中连接相邻的元素 # 3、寻找图像中明显的极大值或极小值区 # 4、求出图像的梯度 # 使用滤波窗口大小为15*15 kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (size, size)) dark_channel = cv2.erode(min_channel, kernel) return dark_channel 腐蚀前： 腐蚀后： 2、大气光值由论文可知，如果有一个图像中，存在一个无限远的距离的像素存在，这个时候，此像素的透射率几乎为0。这个图像中最亮最亮的值所在的像素可以被看做是雾遮盖的程度最大也是其值可以看做是几乎等同于 $A$ 。 我们可以从暗通道图中求取大气光值 $A$ 在暗通道图中按照亮度的大小提取最亮的前0.1%的像素 在原始雾图I(x)中找对应位置上具有最高亮度的点的值，此处我们通过累加求平均值获得相对稳定值 12345678910111213141516def Atmospheric_light(image, dark_channel): image_size = image.shape[0] * image.shape[1] # 总像素数量 pixel_num = int(max(math.floor(image_size / 1000), 1)) # 提取的像素数量 dark_vec = dark_channel.reshape(image_size) # 将暗通道图的值转为一维 image_vec = image.reshape(image_size, 3) indices = dark_vec.argsort()[-pixel_num:] # 前0.1%的像素下标 atmosphere_max = np.zeros([1, 3]) # 求取平均值 for ind in range(0, pixel_num): atmosphere_max += image_vec[indices[ind]] A = atmosphere_max / pixel_num return A 3、透射率根据已有公式，论文中经过推导得到的透射率计算公式如下：$$t(x) &#x3D; \\ 1- \\omega \\min\\limits_c (\\min\\limits_{y \\in \\Omega(x)} ( \\frac{I^c(y)}{A^c}) )$$ 12345678def TransmissionEstimate(image, A, size): omega = 0.95 # 论文里一般采用0.95 for i in range(0, 3): image[:, :, i] /= A[i] # 论文里说明的后者是image图像的暗通道 transmission = 1 - omega * DarkChannel(image, size) return transmission 根据论文中的说明，实际上，$\\min\\limits_c (\\min\\limits_{y \\in \\Omega(x)} ( \\frac{I^c(y)}{A^c}) )$ 就相当于 $ \\frac{I^c(y)}{A^c}$ 的暗通道图像 4、引导滤波 (Guided Filter )（该部分为优化效果，未在原文中提出，此处的实现主要参考自 https://zhuanlan.zhihu.com/p/36813673） （同时opencv 3.0 中也添加了guided filter的API，可以直接调用） 引导图滤波器是一种自适应权重滤波器，能够在平滑图像的同时起到保持边界的作用 优点： 能够克服双边滤波的梯度翻转现象，在滤波后图像的细节上更优 较之传统双边滤波效率高，时间复杂度为O(N)，N是像素个数 原论文中的 Guided Filter 的伪代码如下$$1:mean_I &#x3D; f_{mean} (I) \\\\ \\ \\ \\ \\ mean_p &#x3D; f_{mean} (p)\\\\ \\ \\ \\ \\ \\ \\ \\ corr_I &#x3D; f_{mean} (I. *I)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ corr_{Ip} &#x3D; f_{mean} (I.*p)\\ 2:var_I &#x3D; corr_I - mean_I.*mean_I \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ cov_{Ip} &#x3D; -corr{Ip} - mean_I. *mean_p \\ 3:a &#x3D; cov_{Ip}.&#x2F;(var_I + \\epsilon) \\\\ \\ \\ \\ \\ \\ \\ \\ \\ b &#x3D; mean_p - a.*mean_I\\ 4:mean_a &#x3D; f_{mean}(a)\\ \\ \\ \\ \\ \\ mean_b &#x3D; f_{mean}(b) \\ 5:q &#x3D; mean_a. * I + mean_b$$ 依照该伪代码在python中使用 opencv 实现如下： 1234567891011121314151617def Guidedfilter(image, p, r, eps): mean_I = cv2.boxFilter(image, cv2.CV_64F, (r, r)) mean_p = cv2.boxFilter(p, cv2.CV_64F, (r, r)) corr_I = cv2.boxFilter(image * image, cv2.CV_64F, (r, r)) corr_IP = cv2.boxFilter(image * p, cv2.CV_64F, (r, r)) var_I = corr_I - mean_I * mean_I cov_Ip = corr_IP - mean_I * mean_p a = cov_Ip / (var_I + eps) b = mean_p - a * mean_I mean_a = cv2.boxFilter(a, cv2.CV_64F, (r, r)) mean_b = cv2.boxFilter(b, cv2.CV_64F, (r, r)) q = mean_a * image + mean_b return q 【未使用引导滤波的结果】 【使用引导滤波的结果】 5、去雾之后的结果图像 $J(x)$由论文中的公式$$J(x) &#x3D; \\frac{I(x)-A}{max(t(x), t_0)} + A$$可得 12345678def Recover(image, t, A, t0 = 0.1): res = np.empty(image.shape,&#x27;float64&#x27;) t = cv2.max(t, t0) # 论文中的t_0 为0.1 for i in range(0, 3): res[:, :, i] = (image[:, :, i] - A[i]) / t + A[i] return res 在论文中提到一般给 $t_0$ 的取值为 0.1 三、实验结果及分析【实验结果】 当去雾之后，画面整体颜色偏暗，对比度较高 不过我在实验中发现对一下代码进行修改可得到一些不同的结果 12345678910def TransmissionEstimate(image, A, size): omega = 0.95 # image_temp = np.empty(image.shape,&#x27;float64&#x27;) for i in range(0, 3): # image_temp[:, :, i] = image[:, :, i] / A[i] image /= A[i] # 论文里说明的后者是image图像的暗通道 # transmission = 1 - omega * DarkChannel(image_temp, size) transmission = 1 - omega * DarkChannel(image, size) return transmission 在计算透射率时直接对原图除以大气光强，可以使得最终结果更加明亮，类似一种高对比度、高曝光的效果 在整个实验中，Guided filter起到了很大的作用，并且一开始为用任何优化实现原文时，得到的结果并不好，对于数据集中的雾霾较为浓厚的图片，整体有一种偏蓝的效果，我猜测应该是图片大多位于室内，再加上人为造成了浓雾弥漫的效果，使得大气光值的计算出现了问题。 Ⅱ、超分辨率算法 Real-ESRGAN 和 Real-CUGAN一、相关论文及链接腾讯——《Real-ESRGAN: Training Real-World Blind Super-Resolution with Pure Synthetic Data》 论文地址：https://arxiv.org/pdf/2107.10833.pdf（下文中所以公式及图片均引用自该论文） 项目地址：https://github.com/XPixelGroup/BasicSR B站——《Real Cascade U-Nets for Anime Image Super Resolution》 项目地址：https://github.com/bilibili/ailab/tree/main/Real-CUGAN 超分重建相关数据集下载地址：https://data.vision.ee.ethz.ch/cvl/DIV2K/ Squirrel Anime Enhance下载地址：https://github.com/Justin62628/Squirrel-RIFE/releases/tag/v0.0.3 二、超分辨率1、简介超分辨率是计算机视觉的一个经典应用。SR是指通过软件或硬件的方法，从观测到的低分辨率图像重建出相应的高分辨率图像（说白了就是提高分辨率），在监控设备、卫星图像遥感、数字高清、显微成像、视频编码通信、视频复原和医学影像等领域都有重要的应用价值。 传统的超分辨率重建技术有基于插值的图像超分辨率和基于重建的图像超分辨率等 2、基于深度学习的图像超分辨率重建技术基于深度学习的图像超分辨率重建的研究流程如下： 首先找到一组原始图像 Image1 然后将这组图片降低分辨率为图像 Image2 通过各种神经网络结构，将 Image2 超分辨率重建为 Image3 比较Image1与Image3，验证超分辨率重建的效果，根据效果调节神经网络中的节点模型和参数 反复执行，直到达到较好的效果 3、两种常用的评价超分的指标——PSNR和SSIM对超分辨率的质量进行定量评价常用的两个指标是 PSNR (Peak Signal-to-Noise Ratio)和SSIM（Structure Similarity）。这两个值越高代表重建结果的像素值和标准越接近。 PSNR（Peak Signal to Noise Ratio）峰值信噪比$$MSE &#x3D; \\frac{1}{H ×W} \\sum \\limits_{i &#x3D; 1}^H \\sum \\limits_{j&#x3D;1}^W(X(i,j)-Y(i,j))^2$$ $$PSNR &#x3D; 10log_{10}(\\frac{(2^n-1)^2}{MSE})$$ 其中 MSE 表示当前图像 X 与参考图像 Y 的均方误差，H、W分别为图像的高和宽，n为每像素的比特数（比如灰度图的单个像素占8bit） PSNR 的单位是 db，数值越大表示失真越小 SSIM（Structure Similarity ）结构相似性$$SSIM(x,y) &#x3D; \\frac{(2\\mu_x\\mu_y + c_1) (2\\sigma_{xy} +c_2)} {(\\mu_x^2 +\\mu_y^2+c_1) (\\sigma_x^2+\\sigma_y^2+c_2)}$$ 其中 $u$ 为平均值、$\\sigma^2$ 为方差，$\\sigma_{xy}$ 为协方差 ，$c_1 &#x3D; (k_1L)^2$，$c_2 &#x3D; (k_2L)^2$ 是用来维持稳定的常数，$L$ 是像素值的动态范围。$k_1$ &#x3D; 0.01 ,$k_2$ &#x3D; 0.03 结构相似性的范围为-1到1，当两张图像一模一样时，SSIM的值等于1。 三、Real-ESRGAN由腾讯ARC实验室发表。在单张图片超分辨率(Single Image Super-resolution)的问题中，许多方法都采用传统的 Bicubic 方法实现降采样，但是这与现实世界的降采样情况不同，太过单一。盲超分辨率(Blind Super-resolution)旨在恢复未知且复杂的退化的低分辨率图像。根据其使用的降采样方式不同，可以分为显式建模(explicit modeling)和隐式建模(implicit modeling)。 显式建模：经典的退化模型由模糊、降采样、噪声和 JPEG压缩组成。但是现实世界的降采样模型过于复杂，仅通过这几个方式的简单组合无法达到理想的效果。 隐式建模：依赖于学习数据分布和采用 GAN 来学习退化模型，但是这种方法受限于数据集，无法很好的泛化到数据集之外分布的图像 【降级模型】 First-order降级模型如下： 其中，x代表降级后的图像，D代表降级函数，y代表原始图像，k代表模糊核，r代表缩小比例，n代表加入的噪声，JPEG代表进行压缩。 在现实世界中，图像分辨率的退化通常是由多种不同的退化复杂组合而成的。 因此，作者将经典的一阶退化模型(“first-order” degradation model)拓展现实世界的高阶退化建模(“high-order” degradation modeling)，即利用多个重复的退化过程建模，每一个退化过程都是一个经典的退化模型。但是为了平衡简单性和有效性，作者在代码中实际采用的是二阶退化模型(“second-order” degradation model)。流程如下图所示： 对于模糊核k，本方法使用各项同性（isotropic）和各向异性（anisotropic）的高斯模糊核。 对于Resize操作，常用的方法又双三次插值、双线性插值、区域插值—由于最近邻插值需要考虑对齐问题，所以不予以考虑。在执行缩小操作时，本方法从提到的3种插值方式中随机选择一种。 对于噪声操作，本方法同时加入高斯噪声和服从泊松分布的噪声。同时，根据待超分图像的通道数，加入噪声的操作可以分为对彩色图像添加噪声和对灰度图像添加噪声。 JPEG压缩，本方法通过从[0, 100]范围中选择压缩质量，对图像进行JPEG压缩，其中0表示压缩后的质量最差，100表示压缩后的质量最好。 First-order由于使用相对单调的降级方法，其实很难模仿真实世界中的图像低分辨模糊情况。因此，作者提出的High-order其实是为了使用更复杂的降级方法，更好的模拟真实世界中的低分辨模糊情况，从而达到更好的学习效果。 文中提出的高阶降级模型公式如下：$$x &#x3D; D^n(y)&#x3D; (D_n \\circ\\cdot\\cdot\\cdot D_2 \\circ D_1)(y)$$上式，其实就是对First-order进行多次重复操作，也就是每一个D都是执行一次完整的First-order降级，作者通过实验得出，当执行2次First-order时生成的数据集训练效果最好 【sinc filter】 之后还设置sinc filter来模拟振铃和过冲伪影现象，$sinc$ 滤波器的核如下：$$k(i,j) &#x3D; \\frac{\\omega_c}{2\\pi \\sqrt {i^2 + j^2}}J _1(\\omega_c \\sqrt{i^2 + j^2})$$其中 $(i,j)$ 为核的坐标，$w_c$ 为截止频率，$J_1$ 为一阶的第一种修正Bessel函数。 上图为不同截止频率下的振铃和过冲伪影效果 但是因为采用了高阶退化模型，使得退化空间相比于 ESRGAN 来说大得多，训练也就更加具有挑战性。因此作者在 ESTGAN 的基础上做了两个改动： 使用 U-Net 判别器替换 ESRGAN 中使用的 VGG 判别器 引入 spectral normalization 来使得训练更加稳定，并减少 artifacts。 【生成网络模型】 在网络模型方面，Real-ESRGAN扩展了原来的ESRGAN，同时支持x1,x2,x4。Real-ESRGAN采用与ESRGAN相同的生成网络。对于比例因子×2和×1，使用 pixel-unshuffle 操作（可理解为通过扩大图像通道而对图像尺寸进行压缩），以降低图像分辨率为前提，对图像通道数进行扩充，然后将处理后的图像输入网络进行超分辨重建。 【对抗网络模型】 由于使用的复杂的构建数据集的方式，所以需要使用更先进的判别器对生成图像进行判别。之前的ESRGAN的判别器更多的集中在图像的整体角度判别真伪，而使用U-Net 判别器可以在像素角度，对单个生成的像素进行真假判断，这能够在保证生成图像整体真实的情况下，注重生成图像细节。 【训练方法】 预训练一个以 PSNR 为目标的模型，并采用 L1 loss，得到 Real-ESRNet 用 Real-ESRNet 初始化 Real-ESRGAN 中的 Generator，然后训练 Real-ESRGAN，采用 L1 Loss、perceptual loss 和 GAN loss 三种组合的 loss。 【实验结果】 四、Real-ESRGAN 和 Real-CUGAN性能对比详细对比（以下表格在 Real-CUGAN 项目中可见） Real-ESRGAN(Anime6B) Real-CUGAN 训练集 私有二次元训练集，量级与质量未知 百万级高清二次元patch dataset 推理耗时(1080P) 2.2x 1x 效果(见对比图) 锐化强度最大，容易改变画风，线条可能错判，虚化区域可能强行清晰化 更锐利的线条，更好的纹理保留，虚化区域保留 兼容性 PyTorch支持，VapourSynth支持，NCNN支持 同Waifu2x，结构相同，参数不同，与Waifu2x无缝兼容 强度调整 不支持 已完成4种降噪程度版本和保守版，未来将支持调节不同去模糊、去JPEG伪影、锐化、降噪强度 尺度 仅支持4倍 已支持2倍、3倍、4倍，1倍训练中 五、Squirrel Anime Enhance Squirrel Anime Enhance是一款基于多个开源超分算法的中文超分软件，具有以下优势： 集成了 realCUGAN, realESR, waifu2x 三种超分算法 拥有友好的 GUI 图形界面，方便使用 使用pipe传输视频帧，无需拆帧到本地，拯救硬盘 更小的显存、内存占用，更快的速度 拥有预览界面，能更好地了解超分情况 安装较为简单，解压后，双击启动SAE.bat即可启动软件 【使用方式】 在如下界面设置输入的图片或视频文件或其所在文件夹，并设置输出文件夹 在如下界面设置超分算法与模型，目前主要集成了realCUGAN, realESR,和waifu2x三种超分算法，每一种超分算法下都有相对应的超分模型。 waifu2x: models cunet：一般用于动漫超分 models photo：一般用于实拍 models style anime：一般用于老动漫 realESR: realESRGAN模型，目前支持2x和4x realESRNet模型：效果较为模糊，细节处不够精密，个人感觉不如realESRGAN模型 realCUGAN： up2x-latest-conservative pth up2x-latest-denoise_2.pth up3x-latest-consevative.pth up3x-latest- denoise_3.pth up4x-latest-conservative pth up4x-latest-denoise_3.pth up4x-latest-no denoise.pth 其中 Denoise 为降噪版，主要针对较多噪声的情况，conservative为保守版，处理效果较为保守，不会造成严重的失真。No-Denoise为无降噪版，较为通用。 输出分辨率预设：提供倍数及具体像素值的选择 在以上设置完成后，点击一键压制可以开始进行超分操作。 【运行界面】 六、实验结果对于Real-ESRGAN 和 Real-CUGAN，下载其在项目地址中公布的release发行版本 通过调用一下命令来运行 12# ./realesrgan-ncnn-vulkan.exe -i 输入图像.jpg -o 输出图像.png -n 模型名字# ./realcugan-ncnn-vulkan.exe -i input.jpg -o output.png 【结果展示】 [^分辨率说明]: 由于Real-ESRGAN 目前仅支持 X4 ，所以分辨率均使用4倍 原图：分辨率为1600 × 1055 结果图：分辨率为 6400 × 4220 左为 Real-ESRGAN 右图为 Real-CUGAN 原图：分辨率为1920 × 1080 结果图：分辨率为 7680 × 4320 左为 Real-ESRGAN 右图为 Real-CUGAN 原图：分辨率为120 × 80 结果图：分辨率为 7680 × 4320 左为 Real-ESRGAN 右图为 Real-CUGAN 【结果分析】 本机环境为 Intel(R) Core(TM) i5-9300H CPU @ 2.40GHz 2.40 和 GeForce GTX 1650 ，性能较差 ，无法用于训练。在运行耗时方面，在直接使用exe 文件运行时对于一张标准的 1920 ×1080 图片，Real-ESRGAN 耗时2分钟左右，而Real-CUGAN 仅需四五秒。目前的Real-ESRGAN 仅支持图片4倍放大超分辨率，而Real-CUGAN支持2、3、4倍，使得实验比较均使用×4分辨率进行。总体而言，B站的 Real-CUGAN 效果较好，耗时较短，从我个人的肉眼观察角度出发，腾讯的RealESRGAN纹理保留性较差，较为模糊、细节有所丢失，表现较弱，而B站的 Real-CUGAN对于分辨率较高的图片细节处更为丰富，对于原图较为明亮的图片超分后也可以很好的保持光照亮度。","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"}]},{"title":"基于Unity和MySQL的数据库课设","slug":"数据库课程实验","date":"2022-07-27T09:47:18.096Z","updated":"2022-07-26T03:54:54.285Z","comments":true,"path":"2022/07/27/数据库课程实验/","link":"","permalink":"http://example.com/2022/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/","excerpt":"(前排提示:为了凑字数导致内容较水) 摘要本实验采用的数据库为MySQL数据库，其具有体积小、速度快等优点。本实验的GUI部分采用Unity3D引擎制作，通过编写C#脚本挂载到Unity引擎中，实现了Unity与MySQL之间的连接。在完成基础实验一至五的前提上，依照要求实现了一个小型书籍信息管理系统 ，具有增删改查等基本功能，同时还可以根据一定要求进行排序，并且创建了两个图表对数据信息进行汇总，便于后续分析。 关键词MySQL、Unity、、C#、书籍信息管理","text":"(前排提示:为了凑字数导致内容较水) 摘要本实验采用的数据库为MySQL数据库，其具有体积小、速度快等优点。本实验的GUI部分采用Unity3D引擎制作，通过编写C#脚本挂载到Unity引擎中，实现了Unity与MySQL之间的连接。在完成基础实验一至五的前提上，依照要求实现了一个小型书籍信息管理系统 ，具有增删改查等基本功能，同时还可以根据一定要求进行排序，并且创建了两个图表对数据信息进行汇总，便于后续分析。 关键词MySQL、Unity、、C#、书籍信息管理 一、实验要求 理解 SQL 定义功能 熟练掌握 SQL 操纵功能 了解 SQL 数据控制功能。 熟练掌握 Oracle、SQL Server、MySQL、DB2、Sybase 或 PostgreSQL 等对数据库的管理和操作，可以采用华为 OpenGauss 数据库。熟练掌握 Visual C++(MFC)、C#、 Qt、Java、PHP 或 Python 等访问数据库的方法，编写学生通讯录或学生选课（不建议）或其他类似的一个小型管理信息系统。 【关于小型管理信息系统】 熟练掌握 Visual C++、C#、Qt、Java、PHP 或 Python 等访问数据库的方法， 设计和实现学生通讯录或学生选课或类似的一个小型管理信息系统。要求具有数 据的增加、删除、修改和查询的基本功能，并尽可能提供较多的查询功能，集成 一半以上实验一～实验五的功能，用户界面要友好。可选内容（加分项）：数据库中存放 100 万条记录，测试访问时间；如效率较低，提供优化方案。 二、实验依赖1、MySQLⅠ、MySQL 特点 功能强大 支持跨平台 运行速度快 支持面向对象 安全性高 成本低 支持各种开发语言 数据库存储容量大 支持强大的内置函数 Ⅱ、MySQL版本本实验采用 MySQL 8.0版本 安装地址：https://dev.mysql.com/downloads/installer/ 安装包： 2、UnityUnity 是实时3D互动内容创作和运营平台 。包括游戏开发、美术、建筑、汽车设计、影视在内的所有创作者，借助Unity将创意变成现实。Unity平台提供一整套完善的软件解决方案，可用于创作、运营和变现任何实时互动的2D和3D内容，支持平台包括手机、平板电脑、PC、游戏主机、增强现实和虚拟现实设备。 本实验采用Unity制作GUI界面 ，全部代码均在Unity中通过C#编写， 所用Unity编辑器的版本为 2021.2.7f1c1，渲染管线为 Built-in 渲染管线，新建项目类型为普通3D项目，所以代码编辑器为 Visual Studio 2019。 3、相关参考资料MySQL的安装：https://blog.csdn.net/qq_59636442/article/details/123058454 PHP与MySQL的连接：http://c.biancheng.net/view/7668.html Unity连接MySQL： https://blog.csdn.net/Caijingxiang/article/details/107325645 https://zhuanlan.zhihu.com/p/508391104 三、数据部分1、数据来源本实验完成了一个书籍信息管理系统，其中书籍和作者信息为在豆瓣读书网页中爬取所得 【方法】 用python编写网络爬虫 （1）设置url1url = &quot;https://book.douban.com/subject/35635639&quot; 后面的数字 35635639 为豆瓣数据库中对每个书籍的编号 通过改变数字来获取书籍信息 （2）建立请求，获取源代码 1r = requests.get(url, headers=&#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0&#x27;&#125;) 注意：必须在 url 后面加上 headers ，否则请求会被拒绝。 （3）根据网页源代码，构建查匹配对应数据所需的正则表达式123pattern1 = re.compile(&#x27;&lt;meta name=&quot;keywords&quot; content=&quot;(.*?)&quot;&gt;&#x27;) # 基本信息pattern2 = re.compile(&#x27;&lt;strong class=&quot;ll rating_num &quot; property=&quot;v:average&quot;&gt; (.*?) &lt;/strong&gt;&#x27;) # 豆瓣评分pettern3 = re.compile(&#x27;&lt;a class=&quot;&quot; href=&quot;/search/%E9%87%91%E5%86%89&quot;&gt;(.*?)&lt;/a&gt;&#x27;) # 译者，有的书此处为空 （4）进行匹配查询123data = re.findall(pattern1, r.text)star = re.findall(pattern2, r.text)translate = re.findall(pettern3, r.text) （5）字符串连接12str = &#x27;insert into books values (&quot;&#x27; + s[0] + &#x27;&quot;,&quot;&#x27; + s[1] + &#x27;&quot;,&quot;&#x27; + s[2] + &#x27;&quot;,&quot;&#x27; + s[3] + &#x27;&quot;,&#x27; + &#x27; &quot;无&quot; ,&quot;&#x27; + star[ 0] + &#x27;&quot; , &quot;未借出&quot;);&#x27; 将上述爬取到的信息连接起来，形成一条具有插入功能的MySQL语句，方便后续运行。 【输出案例】 1insert into books values (&quot;法治的细节&quot;,&quot;罗翔&quot;,&quot;云南人民出版社&quot;,&quot;2021-11&quot;, &quot;无&quot; ,&quot;8.4&quot; , &quot;未借出&quot;); 【一些问题】 豆瓣对书籍及作者信息有时收集的并不完全，导致爬取到的数据很少有能用的。 下图是一个完整的书籍信息，书籍编号为 35635639 下图书籍缺少豆瓣评分信息，书籍编号为 35635619 【解决方法】 在大批量爬取数据后，手动删除无用信息，留下具有完整信息的书籍，将其写入到数据库中。 2、详细数据（1）书籍信息书籍信息表 books，具有以下7个属性 书名 （主属性） 作者 出版社 出版时间 译者 （可无） 豆瓣评分 借阅状态 使用如下sql语句创建 1234567891011create table books( bookname CHAR(40) Primary key, author CHAR(40) , producer CHAR(40), producetime CHAR(40), translater CHAR(40) , star CHAR(10), borrowstate CHAR(20), foreign key(auther) references authors(authorname)); 在MySQL中存储如下 （仅部分数据） （2）作者信息作者信息表 authors ，具有如下 5个属性 作者姓名 作者性别 出生日期 出生地 国籍 使用如下 sql 语句创建 12345678create table authers( auther CHAR(40) Primary key, sex CHAR(40) , birthtime CHAR(40), birtharea CHAR(40), country CHAR(10) ,); 在MySQL中存储如下 （仅部分数据） （3）学生信息学生信息表 students ，具有如下 5个属性 学生姓名 学号 性别 系别 借阅书籍 使用如下 sql 语句创建 123456789create table students( name CHAR(20), Sno CHAR(10), Sex CHAR(10), Sdept CHAR(10), book CHAR(20), FOREIGN KEY (book) REFERENCES books(bookname),); 在MySQL中存储如下 （仅部分数据） 3、数据 E-R 图 四、具体实验流程1、建立 Unity 与 MySQL 之间的连接创建 C# 脚本 SqlAccess.cs ，完整代码如下，具体结束见注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151using System;using System.Data;using MySql.Data.MySqlClient;using UnityEngine;using System.Text;public class SqlAccess&#123; public static MySqlConnection dbConnection; //如果只是在本地的话，写localhost就可以。 // static string host = &quot;localhost&quot;; //如果是局域网，那么写上本机的局域网IP static string host = &quot;localhost&quot;; static string port = &quot;3306&quot;; static string username = &quot;root&quot;; static string pwd = &quot;HUNXIGUILAI2019&quot;; static string database = &quot;ekkodb&quot;; public SqlAccess() &#123; OpenSql(); &#125; /// &lt;summary&gt; /// 连接数据库 /// &lt;/summary&gt; public static void OpenSql() &#123; try &#123; string connectionString = string.Format(&quot;server = &#123;0&#125;;port=&#123;1&#125;;database = &#123;2&#125;;user = &#123;3&#125;;password = &#123;4&#125;;charset=utf8&quot;, host, port, database, username, pwd); Debug.Log(&quot;connectionString:&quot;+ connectionString); dbConnection = new MySqlConnection(connectionString); dbConnection.Open(); Debug.Log(&quot;建立连接&quot;); &#125; catch (Exception e) &#123; throw new Exception(&quot;服务器连接失败,请重新检查是否打开MySql服务。&quot; + e.Message.ToString()); &#125; &#125; /// &lt;summary&gt; /// 关闭数据库连接 /// &lt;/summary&gt; public void Close() &#123; if (dbConnection != null) &#123; dbConnection.Close(); dbConnection.Dispose(); dbConnection = null; &#125; &#125; // 增加操作 public DataSet Additem(string tablename,string[] datavalues) &#123; StringBuilder query = new StringBuilder(); query.Append(&quot;INSERT into &quot;); query.Append(tablename); query.Append(&quot; VALUES (&quot;); query.Append(&quot;&#x27;&quot;); query.Append(datavalues[0]); query.Append(&quot;&#x27;&quot;); for(int i = 1;i &lt;datavalues.Length;i++) &#123; // 判断类型 query.Append(&quot;,&#x27;&quot;); query.Append(datavalues[i]); query.Append(&quot;&#x27;&quot;); &#125; query.Append(&quot;);&quot;); Debug.Log(&quot;添加数据:&quot; + query.ToString()); return ExecuteQuery(query.ToString()); &#125; // 查询操作 public DataSet SelectWhere(string tableName, string[] items, string bookname) &#123; StringBuilder query = new StringBuilder(); query.Append(&quot;SELECT &quot;); query.Append(items[0]); for (int i = 1; i &lt; items.Length; ++i) &#123; query.Append(&quot;, &quot;); query.Append(items[i]); &#125; query.Append(&quot; FROM &quot;); query.Append(tableName); if( bookname != null) &#123; query.Append(&quot; WHERE &quot;); query.Append(&quot;bookname = &quot;); query.Append(&quot;&#x27;&quot;); query.Append(bookname); query.Append(&quot;&#x27;&quot;); query.Append(&quot;;&quot;); &#125; Debug.Log(&quot;查询数据:&quot; + query.ToString()); return ExecuteQuery(query.ToString()); &#125; // 删除操作 public DataSet Delete(string tablename,string bookname) &#123; // delete from books where bookname = &quot;浮木&quot;; StringBuilder query = new StringBuilder(); query.Append(&quot;DELETE FROM &quot;); query.Append(tablename); query.Append(&quot; WHERE bookname = &quot;); query.Append(&quot;&#x27;&quot;); query.Append(bookname); query.Append(&quot;&#x27;&quot;); query.Append(&quot;;&quot;); Debug.Log(&quot;删除数据:&quot; + query.ToString()); return ExecuteQuery(query.ToString()); &#125; // 执行 Sql 语句 public static DataSet ExecuteQuery(string sqlString) &#123; if (dbConnection.State == ConnectionState.Open) &#123; DataSet ds = new DataSet(); try &#123; MySqlDataAdapter da = new MySqlDataAdapter(sqlString, dbConnection); da.Fill(ds); &#125; catch (Exception ee) &#123; throw new Exception(&quot;SQL:&quot; + sqlString + &quot;/n&quot; + ee.Message.ToString()); &#125; finally &#123; &#125; return ds; &#125; return null; &#125;&#125; 【踩坑记录】1、连接问题 1Exception: 服务器连接失败，请重新检查是否打开MySql服务。The given key &#x27;utf8mb4&#x27; was not present in the dictionary. 解决办法： 123// 在string末尾添加 “charset=utf8”string connectionString = string.Format(&quot;server = &#123;0&#125;;port=&#123;1&#125;;database = &#123;2&#125;;user = &#123;3&#125;;password = &#123;4&#125;;charset=utf8&quot;, host, port, database, username, pwd); 2、查询问题问题11Exception: SQL:select cno, cname, cpno, ccredit from c/nThe given key &#x27;utf8mb4&#x27; was not present in the dictionary. 主要原因： MySql.Data 的版本过低（此版本为5.2.7） 问题21Exception: 服务器连接失败，请重新检查是否打开MySql服务。Authentication failed, see inner exception. 主要原因： MySql.Data 的版本过高（此版本为6.9.9） 解决方法：以上问题都是由于 MySql.Data.dll 的版本问题导致的 我所用的Unity版本为 2021.2.7f1c1 不同的 MySql.Data.dll 的下载地址： https://downloads.mysql.com/archives/c-net/ 经过多次实验 找到的合适的 MySql.Data.dll 的版本为 6.1.6 成功建立连接并实现查询 1SELECT Cno, Cname, Cpno, Ccredit FROM C 2、登陆界面Ⅰ、界面绘制及功能介绍 用户名 与 密码 为两个 Input Field 组件，可以获取用户输入 用户输入 正确的用户名和密码后可登入数据库，若用户名或密码错误，会出现警告 Ⅱ、功能实现（1）引入所需命名空间1234using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; （2）声明所需的各个变量123456789public GameObject cuowu;public InputField zhanghao;public InputField mima;public Button queding_btn;public GameObject maincanvas;string zhanghaostr ;string mimastr ; （3）在启动时进行绑定与初始化设置1234567void Start()&#123; cuowu.SetActive(false); maincanvas.SetActive(false); queding_btn.onClick.AddListener(log); mima.contentType = InputField.ContentType.Password;&#125; （4）按钮触发的登陆操作123456789101112131415void log()&#123; string myzh = zhanghao.text; string mymima = mima.text; if( string.Compare(zhanghaostr,myzh)== 0 &amp;&amp; string.Compare(mimastr,mymima) == 0 ) &#123; transform.gameObject.SetActive(false); maincanvas.gameObject.SetActive(true); &#125; else &#123; cuowu.SetActive(true); &#125;&#125; 3、主界面Ⅰ、界面绘制及功能介绍 主界面一共有四个按钮事件，通过点击各个按钮显示对应的界面，左上角 × 为关闭整个应用程序，在程序打包后生效。 Ⅱ、功能实现（1）引入命名空间123456using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using XCharts.Runtime;using System.Data; （2）初始化所需的各个变量及组件12345678910111213141516171819public Button sbtn;public Button abtn;public Button alterbtn;public Button showbtn;public Button quitbnt;public Canvas selcanva;public Canvas addcanva;public Canvas altercanva;public Canvas showchartcanva;public PieChart chart;public BarChart barchart;private Serie serie;ArrayList stars = new ArrayList();public GameObject tablecanvas;public GameObject table_prefab;private GameObject mytable; （3）对按钮、Canvas等组件进行初始化及绑定操作12345678910111213void Start()&#123; selcanva.gameObject.SetActive(false); addcanva.gameObject.SetActive(false); altercanva.gameObject.SetActive(false); showchartcanva.gameObject.SetActive(false); sbtn.onClick.AddListener(showtable ); abtn.onClick.AddListener(delegate &#123; showandclose(addcanva); &#125;); alterbtn.onClick.AddListener(delegate &#123; showandclose(altercanva); &#125;); showbtn.onClick.AddListener(xiugai); quitbnt.onClick.AddListener(tuchu);&#125; （4）关闭&#x2F;显示 功能123456789void showandclose(Canvas thiscanva)&#123; selcanva.gameObject.SetActive(false); addcanva.gameObject.SetActive(false); altercanva.gameObject.SetActive(false); showchartcanva.gameObject.SetActive(false); thiscanva.gameObject.SetActive(true); &#125; （5）退出应用程序1234void tuchu()&#123; Application.Quit();&#125; （6）对第四部分的chart图表进行更新修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void xiugai()&#123; int a = 0; int b = 0; int c = 0; selcanva.gameObject.SetActive(false); addcanva.gameObject.SetActive(false); altercanva.gameObject.SetActive(false); showchartcanva.gameObject.SetActive(true); SqlAccess sql = new SqlAccess(); string[] items = &#123; &quot;star&quot; &#125;; string tablename = &quot;books&quot;; string bookname = null; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; str += row[column]; float num = float.Parse(str); if (num &gt;= 9.0f) a++; else if (num &lt;= 8.0f) c++; else b++; //stars.Add(float.Parse(str)); &#125; &#125; &#125; chart.UpdateData(0, 0, a); chart.UpdateData(0, 1, b); chart.UpdateData(0, 2, c); var yAxis = barchart.GetChartComponent&lt;YAxis&gt;(); yAxis.minMaxType = Axis.AxisMinMaxType.Default; barchart.RemoveData(); serie = barchart.AddSerie&lt;Bar&gt;(&quot;Star&quot;); barchart.AddXAxisData(&quot;小于8.0&quot;); barchart.AddData(0, c); barchart.AddXAxisData(&quot;8.0-9.0&quot;); barchart.AddData(0, b); barchart.AddXAxisData(&quot;大于9.0&quot; ); barchart.AddData(0, a);&#125; （7）通过预制体的不断删除实例化来更新通过调用此函数解决了更新脚本只执行一次的bug 1234567891011void showtable()&#123; Destroy(tablecanvas.transform.GetChild(0).gameObject); mytable = Instantiate(table_prefab); mytable.transform.SetParent(tablecanvas.transform, false); selcanva.gameObject.SetActive(true); addcanva.gameObject.SetActive(false); altercanva.gameObject.SetActive(false); showchartcanva.gameObject.SetActive(false);&#125; 4、选择查看界面Ⅰ、界面绘制及功能介绍 此处程序尚未执行，表中全部为空 【运行程序】 点击 “书籍信息表” 点击 “作者信息表” 点击 “学生信息表” 此外，表中增加了排序功能 点击 “豆瓣评分” 表头，可以根据豆瓣评分高低进行升序排序 点击 “豆瓣评分” 表头，可以根据豆瓣评分高低进行升序排序 Ⅱ、功能实现创建 Select.cs 脚本（1）引入命名空间1234using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; （2）初始化变量及组件1234567891011121314151617public Button shubtn;public Button autherbtn;public Button studentbtn;public GameObject shutable;public GameObject authertable;public GameObject studenttable;public GameObject tablecanvas;public GameObject tablecanvas1;public GameObject table_prefab;public GameObject table_prefab1;private GameObject mytable;private GameObject mytable1;public GameObject tishi; （3）变量初始化及按钮绑定123456void Start()&#123; shubtn.onClick.AddListener(showshu); autherbtn.onClick.AddListener(showa); studentbtn.onClick.AddListener(shows); &#125; （4）为各个按钮分配功能123456789101112131415161718192021222324252627282930void showshu()&#123; shutable.SetActive(true); authertable.SetActive(false); studenttable.SetActive(false); tishi.SetActive(true);&#125;void showa()&#123; Destroy(tablecanvas.transform.GetChild(0).gameObject); mytable = Instantiate(table_prefab); mytable.transform.SetParent(tablecanvas.transform, false); shutable.SetActive(false); studenttable.SetActive(false); authertable.SetActive(true); tishi.SetActive(false);&#125;void shows()&#123; Destroy(tablecanvas1.transform.GetChild(0).gameObject); mytable1 = Instantiate(table_prefab1); mytable1.transform.SetParent(tablecanvas1.transform, false); mytable1.gameObject.SetActive(true); shutable.SetActive(false); authertable.SetActive(false); studenttable.SetActive(true);&#125; 为书籍信息表创建 example.cs 脚本（1）引入命名空间1234567using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using WDT;using System.Data;using System; （2）初始化变量及组件123456public WDataTable dataTable;private List&lt;IList&lt;object&gt;&gt; m_datas = null;private List&lt;WColumnDef&gt; m_columnDefs = null;private int m_tempSelectIndex = -1;ArrayList stars = new ArrayList();int row_n; （3）对表格进行赋值初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void Start() &#123; SqlAccess sql = new SqlAccess(); string[] items = &#123; &quot;*&quot; &#125;; string tablename = &quot;books&quot;; string bookname = null; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; // string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; string str = &quot;&quot;; str += row[column]; stars.Add(str); &#125; // Debug.Log(str + &quot;ee&quot;); &#125; &#125; Debug.Log(&quot;changdu:&quot; + stars.Count); row_n = stars.Count / 7; //table.onClick.AddListener(gengxin); m_datas = new List&lt;IList&lt;object&gt;&gt;(); // name is necessary in columnDefs m_columnDefs = new List&lt;WColumnDef&gt; &#123; new WColumnDef() &#123;name = &quot;书名&quot;,width = &quot;15%&quot;&#125;, new WColumnDef() &#123;name = &quot;作者名&quot;,width = &quot;20%&quot;&#125;, new WColumnDef() &#123;name = &quot;出版社&quot;,width = &quot;19%&quot;&#125;, new WColumnDef() &#123;name = &quot;出版时间&quot;,width = &quot;12%&quot;&#125;, new WColumnDef() &#123;name = &quot;译者&quot;,width = &quot;11%&quot;&#125;, new WColumnDef() &#123;name = &quot;豆瓣评分&quot;,&#125;, new WColumnDef() &#123;name = &quot;借阅状态&quot;,&#125;, //new WColumnDef() &#123;name = &quot;译者&quot;, width = &quot;50%&quot;, disableSort = true&#125; &#125;; for (int i = 0; i &lt; row_n; i++) &#123; m_datas.Add(GetRandomData(i)); &#125; dataTable.msgHandle += HandleTableEvent; dataTable.InitDataTable(m_datas, m_columnDefs); &#125; （4）实现表头排序功能的引入、实现表头界面颜色的更改1234567891011121314151617181920public void HandleTableEvent(WEventType messageType, params object[] args)&#123; if (messageType == WEventType.INIT_ELEMENT) &#123; int rowIndex = (int) args[0]; int columnIndex = (int) args[1]; WElement element = args[2] as WElement; if (element == null) return; Text tText = element.GetComponent&lt;Text&gt;(); if (tText == null) return; tText.color = Color.black; &#125; else if (messageType == WEventType.SELECT_ROW) &#123; int rowIndex = (int) args[0]; m_tempSelectIndex = rowIndex; &#125;&#125; （5）为表项内容赋值1234567891011121314151617181920private List&lt;object&gt; GetRandomData(int i )&#123; return new List&lt;object&gt; &#123; // &quot;浮木&quot;, // &quot;杨本芬&quot;, //&quot;四川人民出版社&quot;, // &quot;2018-12&quot;, // &quot;无&quot;, // 8.0 + i, // &quot;未借出&quot; stars[i * 7].ToString(), stars[i * 7 + 1].ToString(), stars[i * 7 + 2].ToString(), stars[i * 7 + 3].ToString(), stars[i * 7 + 4].ToString(), stars[i * 7 + 5].ToString(), stars[i * 7 + 6].ToString() &#125;;&#125; 同理，创建 Aexample.cs 为 “作者信息表” 进行创建及更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using WDT;using System.Data;using System;public class Aexample : MonoBehaviour&#123; public WDataTable dataTable; private List&lt;IList&lt;object&gt;&gt; m_datas = null; private List&lt;WColumnDef&gt; m_columnDefs = null; private int m_tempSelectIndex = -1; ArrayList stars = new ArrayList(); int row_n; void Start() &#123; SqlAccess sql = new SqlAccess(); string[] items = &#123; &quot;*&quot; &#125;; string tablename = &quot;auther&quot;; string bookname = null; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; // string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; string str = &quot;&quot;; str += row[column]; stars.Add(str); &#125; // Debug.Log(str + &quot;ee&quot;); &#125; &#125; Debug.Log(&quot;changdu:&quot; + stars.Count); row_n = stars.Count / 5; //table.onClick.AddListener(gengxin); m_datas = new List&lt;IList&lt;object&gt;&gt;(); // name is necessary in columnDefs m_columnDefs = new List&lt;WColumnDef&gt; &#123; new WColumnDef() &#123;name = &quot;作者名&quot;&#125;, new WColumnDef() &#123;name = &quot;性别&quot;,width = &quot;100&quot;&#125;, new WColumnDef() &#123;name = &quot;出生时间&quot;&#125;, new WColumnDef() &#123;name = &quot;出生地&quot;&#125;, new WColumnDef() &#123;name = &quot;国家&quot;,width = &quot;200&quot;&#125;, //new WColumnDef() &#123;name = &quot;译者&quot;, width = &quot;50%&quot;, disableSort = true&#125; &#125;; for (int i = 0; i &lt; row_n; i++) &#123; m_datas.Add(GetRandomData(i)); &#125; dataTable.msgHandle += HandleTableEvent; dataTable.InitDataTable(m_datas, m_columnDefs); &#125; public void HandleTableEvent(WEventType messageType, params object[] args) &#123; if (messageType == WEventType.INIT_ELEMENT) &#123; int rowIndex = (int)args[0]; int columnIndex = (int)args[1]; WElement element = args[2] as WElement; if (element == null) return; Text tText = element.GetComponent&lt;Text&gt;(); if (tText == null) return; tText.color = Color.black; &#125; else if (messageType == WEventType.SELECT_ROW) &#123; int rowIndex = (int)args[0]; m_tempSelectIndex = rowIndex; &#125; &#125; private List&lt;object&gt; GetRandomData(int i) &#123; return new List&lt;object&gt; &#123; stars[i * 5].ToString(), stars[i * 5 + 1].ToString(), stars[i * 5 + 2].ToString(), stars[i * 5 + 3].ToString(), stars[i * 5 + 4].ToString(), &#125;; &#125;&#125; 同理，创建 Bexample.cs 为 “学生信息表” 进行创建及更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using WDT;using System.Data;using System;public class Bexample : MonoBehaviour&#123; public WDataTable dataTable; private List&lt;IList&lt;object&gt;&gt; m_datas = null; private List&lt;WColumnDef&gt; m_columnDefs = null; private int m_tempSelectIndex = -1; ArrayList stars = new ArrayList(); int row_n; void Start() &#123; SqlAccess sql = new SqlAccess(); string[] items = &#123; &quot;*&quot; &#125;; string tablename = &quot;student&quot;; string bookname = null; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; // string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; string str = &quot;&quot;; str += row[column]; stars.Add(str); &#125; // Debug.Log(str + &quot;ee&quot;); &#125; &#125; Debug.Log(&quot;changdu:&quot; + stars.Count); row_n = stars.Count / 5; //table.onClick.AddListener(gengxin); m_datas = new List&lt;IList&lt;object&gt;&gt;(); // name is necessary in columnDefs m_columnDefs = new List&lt;WColumnDef&gt; &#123; new WColumnDef() &#123;name = &quot;姓名&quot;&#125;, new WColumnDef() &#123;name = &quot;学号&quot;&#125;, new WColumnDef() &#123;name = &quot;性别&quot;&#125;, new WColumnDef() &#123;name = &quot;院系&quot;&#125;, new WColumnDef() &#123;name = &quot;借阅书籍&quot;&#125;, //new WColumnDef() &#123;name = &quot;译者&quot;, width = &quot;50%&quot;, disableSort = true&#125; &#125;; for (int i = 0; i &lt; row_n; i++) &#123; m_datas.Add(GetRandomData(i)); &#125; dataTable.msgHandle += HandleTableEvent; dataTable.InitDataTable(m_datas, m_columnDefs); &#125; public void HandleTableEvent(WEventType messageType, params object[] args) &#123; if (messageType == WEventType.INIT_ELEMENT) &#123; int rowIndex = (int)args[0]; int columnIndex = (int)args[1]; WElement element = args[2] as WElement; if (element == null) return; Text tText = element.GetComponent&lt;Text&gt;(); if (tText == null) return; tText.color = Color.black; &#125; else if (messageType == WEventType.SELECT_ROW) &#123; int rowIndex = (int)args[0]; m_tempSelectIndex = rowIndex; &#125; &#125; private List&lt;object&gt; GetRandomData(int i) &#123; return new List&lt;object&gt; &#123; stars[i * 5].ToString(), stars[i * 5 + 1].ToString(), stars[i * 5 + 2].ToString(), stars[i * 5 + 3].ToString(), stars[i * 5 + 4].ToString(), &#125;; &#125;&#125; DataTable.cs 脚本实现对表格内容进行动态更新和排序功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445using System;using System.Collections.Generic;using System.Linq;using UnityEngine;using UnityEngine.Assertions;using UnityEngine.UI;namespace WDT&#123; public enum WEventType &#123; SELECT_ROW, SELECT_COLUMN, SORT_BY_COLUMN, INIT_ELEMENT, EVENT_COUNT, &#125; public class WColumnDef &#123; public string name; public string headPrefabName; public string elementPrefabName; public string width; public bool disableSort; &#125; public delegate void WMsgHandle(WEventType messageType, params object[] args); public class WDataTable : MonoBehaviour &#123; public class RowElementInfo &#123; public int rowIndex; public WDataTable bindDataTable; public IList&lt;WColumnDef&gt; columnsDefs; &#125; private class SortItem &#123; public SortItem(int indexIn, object itemIn) &#123; rowIndex = indexIn; item = itemIn; &#125; public readonly int rowIndex; public readonly object item; &#125; [HideInInspector] public WMsgHandle msgHandle; public string rowPrefab; public string defaultHeadPrefabName; public string defaultElementPrefabName; public int itemHeight; public int tableWidth; public int tableHeight; public bool isUseSort = true; public bool isUseSelect = true; private bool m_init; private WHead m_head; private LoopVerticalScrollRect m_scrollRect; private RectTransform m_scrollRectTransform; private RectTransform m_scrollbarRectTransform; private IList&lt;IList&lt;object&gt;&gt; m_datas = new List&lt;IList&lt;object&gt;&gt;(); private IList&lt;WColumnDef&gt; m_columnDefs = new List&lt;WColumnDef&gt;(); private readonly IList&lt;RowElementInfo&gt; m_rowInfos = new List&lt;RowElementInfo&gt;(); private readonly IList&lt;int&gt; m_columnWidths = new List&lt;int&gt;(); private readonly List&lt;SortItem&gt; m_sortItems = new List&lt;SortItem&gt;(); #region public public LoopVerticalScrollRect GetLoopScrollRect() &#123; return m_scrollRect; &#125; public float GetPositionByNewSize(float oldPosition, int oldCount, int newCount) &#123; float offset = oldPosition * (itemHeight * oldCount - tableHeight); float newPosition = offset / (itemHeight * newCount - tableHeight); return newPosition; &#125; public float GetPosition() &#123; if (m_scrollRect == null) return 0; return m_scrollRect.verticalNormalizedPosition; &#125; public void SetPosition(float position) &#123; if (m_scrollRect == null) return; m_scrollRect.verticalNormalizedPosition = position; &#125; /// &lt;summary&gt; /// Sorts the index of the by. /// &lt;/summary&gt; /// &lt;param name=&quot;columnIndex&quot;&gt;The index.&lt;/param&gt; public void SortByIndex(int columnIndex) &#123; if (columnIndex &lt; 0 || columnIndex &gt;= m_columnDefs.Count) return; if (m_rowInfos.Count == 0 || !(m_datas[0][columnIndex] is IComparable)) return; m_sortItems.Clear(); for (int i = 0; i &lt; m_datas.Count; i++) m_sortItems.Add(new SortItem(i, m_datas[i][columnIndex])); m_sortItems.Sort((x, y) =&gt; &#123; var cpX = x.item as IComparable; var cpY = y.item as IComparable; if (cpX == null || cpY == null) return 0; return cpX.CompareTo(cpY); &#125;); for (int i = 0; i &lt; m_sortItems.Count; i++) m_rowInfos[i].rowIndex = m_sortItems[i].rowIndex; UpdateByRowInfo(); if (msgHandle != null) msgHandle(WEventType.SORT_BY_COLUMN, columnIndex); &#125; /// &lt;summary&gt; /// update data of the data table. need ensure right data /// &lt;/summary&gt; /// &lt;param name=&quot;datas&quot;&gt;The datas.&lt;/param&gt; public void UpdateData(IList&lt;IList&lt;object&gt;&gt; datas) &#123; if (datas == null) return; if (!m_init) &#123; Debug.LogError(&quot;not init data table&quot;); return; &#125; IList&lt;IList&lt;object&gt;&gt; tDatas = datas; if (!CheckInputData(tDatas, m_columnDefs)) return; if (!CheckConfig()) return; m_datas = datas; m_rowInfos.Clear(); for (int i = 0; i &lt; m_datas.Count; i++) m_rowInfos.Add(new RowElementInfo &#123;rowIndex = i, bindDataTable = this, columnsDefs = m_columnDefs&#125;); UpdateByRowInfo(); &#125; /// &lt;summary&gt; /// Initializes the data table. need ensure right data /// &lt;/summary&gt; /// &lt;param name=&quot;datas&quot;&gt;The datas.&lt;/param&gt; /// &lt;param name=&quot;columnDefs&quot;&gt;&lt;/param&gt; public void InitDataTable(IList&lt;IList&lt;object&gt;&gt; datas, IList&lt;WColumnDef&gt; columnDefs) &#123; if (!CheckInputData(datas, columnDefs)) return; if (!CheckConfig()) return; if (!m_init) Init(); // copy m_datas = datas; m_columnDefs = columnDefs; m_rowInfos.Clear(); for (int i = 0; i &lt; m_datas.Count; i++) m_rowInfos.Add(new RowElementInfo &#123;rowIndex = i, bindDataTable = this, columnsDefs = m_columnDefs&#125;); UpdateColumnWidths(); m_head.SetColumnInfo(m_columnDefs, this); m_scrollRect.prefabSource.prefabName = rowPrefab; UpdateScrollRectSize(); UpdateByRowInfo(); &#125; public IList&lt;object&gt; GetInfosByRowIndex(int rowIndex) &#123; if (rowIndex &lt; 0 || rowIndex &gt;= m_datas.Count) return null; return m_datas[rowIndex]; &#125; public void OnClickRow(int rowIndex) &#123; Debug.Log(&quot;clicked rowIndex&quot; + rowIndex); if (msgHandle != null) msgHandle(WEventType.SELECT_ROW, rowIndex); &#125; public void OnClickColumn(int columnIndex) &#123; if (isUseSort) SortByIndex(columnIndex); Debug.Log(&quot;clicked columnIndex &quot; + columnIndex); if (msgHandle != null) msgHandle(WEventType.SELECT_COLUMN, columnIndex); &#125; public void OnClickButton(int rowIndex, int columnIndex) &#123; Debug.Log(&quot;clicked button row &quot; + rowIndex + &quot; columnIndex &quot; + columnIndex); if (rowIndex == -1) OnClickColumn(columnIndex); &#125; public void OnInitElement(int rowIndex, int columnIndex, WElement element) &#123; if (msgHandle != null) msgHandle(WEventType.INIT_ELEMENT, rowIndex, columnIndex, element); &#125; [ContextMenu(&quot;UpdateSize&quot;)] public void UpdateSize() &#123; if (!m_init) return; UpdateColumnWidths(); m_head.UpdateHeadSize(); UpdateScrollRectSize(); m_scrollRect.RefillCells(); &#125; public int GetWidthByColumnIndex(int columnIndex) &#123; if (columnIndex &lt; 0 || columnIndex &gt;= m_columnWidths.Count) return 0; return m_columnWidths[columnIndex]; &#125; public bool CanSortByColumnIndex(int columnIndex) &#123; if (m_columnDefs == null) return true; if (columnIndex &lt; 0 || columnIndex &gt;= m_columnDefs.Count) return false; if (m_columnDefs[columnIndex] == null) return true; return !m_columnDefs[columnIndex].disableSort; &#125; #endregion private void Init() &#123; m_scrollRect = GetComponentInChildren&lt;LoopVerticalScrollRect&gt;(); m_head = GetComponentInChildren&lt;WHead&gt;(); Assert.IsNotNull(m_scrollRect); Assert.IsNotNull(m_head); m_scrollRectTransform = m_scrollRect.GetComponent&lt;RectTransform&gt;(); m_scrollbarRectTransform = m_scrollRect.verticalScrollbar.GetComponent&lt;RectTransform&gt;(); Assert.IsNotNull(m_scrollRectTransform); Assert.IsNotNull(m_scrollbarRectTransform); m_init = true; &#125; private void UpdateColumnWidths() &#123; if (m_columnDefs == null) return; m_columnWidths.Clear(); if (m_columnDefs == null || m_columnDefs.Count == 0) &#123; for (int i = 0; i &lt; m_columnDefs.Count; i++) &#123; m_columnWidths.Add(tableWidth / m_columnDefs.Count); &#125; &#125; else &#123; int totalWidth = 0; int totalCount = 0; for (int i = 0; i &lt; m_columnDefs.Count; i++) &#123; int width = 0; if (m_columnDefs[i] != null &amp;&amp; !string.IsNullOrEmpty(m_columnDefs[i].width)) &#123; if (m_columnDefs[i].width.Contains(&#x27;%&#x27;)) &#123; string percentString = m_columnDefs[i].width.Replace(&quot;%&quot;, &quot;&quot;); int percent; int.TryParse(percentString, out percent); width = (int) (tableWidth * (percent / 100.0f)); &#125; else &#123; int.TryParse(m_columnDefs[i].width, out width); &#125; &#125; m_columnWidths.Add(width); if (width &gt; 0) &#123; totalCount += 1; totalWidth += width; &#125; &#125; if (totalCount &lt; m_columnDefs.Count) &#123; int otherWidth = (tableWidth - totalWidth) / (m_columnDefs.Count - totalCount); if (otherWidth &lt;= 0) Debug.LogError(&quot;Error columnDef for calculate column width&quot;); for (int i = 0; i &lt; m_columnWidths.Count; i++) &#123; if (m_columnWidths[i] == 0) m_columnWidths[i] = otherWidth; &#125; &#125; &#125; &#125; private void UpdateScrollRectSize() &#123; m_scrollRectTransform.sizeDelta = new Vector2(tableWidth, tableHeight); m_scrollbarRectTransform.anchoredPosition = new Vector2(tableWidth, 0); m_scrollbarRectTransform.sizeDelta = new Vector2(20, tableHeight); &#125; private void UpdateByRowInfo() &#123; m_scrollRect.objectsToFill = m_rowInfos.ToArray(); m_scrollRect.totalCount = m_rowInfos.Count; m_scrollRect.RefillCells(); &#125; private bool CheckConfig() &#123; if (string.IsNullOrEmpty(rowPrefab)) &#123; Debug.LogError(&quot;need set rowPrefab name&quot;); return false; &#125; if (itemHeight &lt;= 0 || tableWidth &lt;= 0 || tableHeight &lt;= 0) &#123; Debug.LogError(&quot;size number greater than zero&quot;); return false; &#125; if (itemHeight &gt; tableHeight) &#123; Debug.LogError(&quot;need itemHeight &lt; tableHeight&quot;); return false; &#125; return true; &#125; private bool CheckInputData(IList&lt;IList&lt;object&gt;&gt; datas, ICollection&lt;WColumnDef&gt; columnDefs) &#123; if (datas == null || columnDefs == null) &#123; Debug.LogError(&quot;datas columnDefs not be null&quot;); return false; &#125; if (datas.Count == 0) &#123; Debug.LogError(&quot;empty data&quot;); return false; &#125; for (int i = 0; i &lt; datas.Count; i++) &#123; if (datas[i].Count != columnDefs.Count) &#123; Debug.LogError(&quot;row data length not equal columns length:&quot; + i); return false; &#125; &#125; foreach (var column in columnDefs) &#123; if (string.IsNullOrEmpty(column.name)) &#123; Debug.LogError(&quot;columnDefs need contain column name&quot;); return false; &#125; if (string.IsNullOrEmpty(defaultHeadPrefabName) &amp;&amp; string.IsNullOrEmpty(column.headPrefabName)) &#123; Debug.LogError(&quot;if defaultHeadPrefabName is empty, columnDefs need contain headPrefabName&quot;); return false; &#125; if (string.IsNullOrEmpty(defaultElementPrefabName) &amp;&amp; string.IsNullOrEmpty(column.elementPrefabName)) &#123; Debug.LogError(&quot;if defaultElementPrefabName is empty, columnDefs need contain elementPrefabName&quot;); return false; &#125; &#125; for (int i = 0; i &lt; columnDefs.Count; i++) &#123; for (int j = 0; j &lt; datas.Count - 1; j++) &#123; if ((datas[j][i] == null) || (datas[j + 1][i] == null)) &#123; if ((datas[j][i] == null) &amp;&amp; (datas[j + 1][i] == null)) continue; Debug.LogError(&quot;data type not same:[&quot; + j + &quot;,&quot; + i + &quot;], [&quot; + (j + 1) + &quot;,&quot; + i + &quot;]&quot;); return false; &#125; if (datas[j][i].GetType() == datas[j + 1][i].GetType()) continue; Debug.LogError(&quot;data type not same:[&quot; + j + &quot;,&quot; + i + &quot;], [&quot; + (j + 1) + &quot;,&quot; + i + &quot;]&quot;); return false; &#125; &#125; return true; &#125; &#125;&#125; 5、添加界面Ⅰ、界面绘制及功能介绍 该界面由 11个输入框组件 和 2个按钮组件 构成 用户通过在本界面输入相应的书籍或者作者信息，可以实现在数据库中添加记录的功能 【例】 注：书籍信息为个人编纂，仅测试用 若输入已有书籍，则会产生报错 Ⅱ、功能实现（1）引入命名空间12345using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using System.Data; （2）对变量及组件进行初始化赋值123456789101112131415161718public InputField nameinput;public InputField autherinput;public InputField producerinput;public InputField ageinput;public InputField tanslaterinput;public InputField starinput;public InputField authernameinput;public InputField authersexinput;public InputField birthinput;public InputField areainput;public InputField countryinput;public Button addbtn;public Button addbtn1;public GameObject shibai;public GameObject chenggong;DataSet ds; （3）对按钮事件进行绑定private void Start() &#123; shibai.SetActive(false); chenggong.SetActive(false); addbtn.onClick.AddListener(Add); addbtn1.onClick.AddListener(Add1); &#125; （4）实现添加书籍信息的功能123456789101112131415161718192021222324void Add()&#123; SqlAccess sql = new SqlAccess(); string tablename = &quot;books&quot;; string bookname = nameinput.text; string auther = autherinput.text; string producer = producerinput.text; string age = ageinput.text; string translate = tanslaterinput.text; string star = starinput.text; string[] datavalues = new string[] &#123;bookname,auther,producer,age,translate,star,&quot;未借出&quot;&#125;; if( bookname != &quot;&quot;) &#123; ds = sql.Additem(tablename, datavalues); chenggong.SetActive(true); &#125; if (ds == null) &#123; shibai.SetActive(true); &#125; &#125; （5）实现添加作者信息的功能1234567891011121314151617181920212223void Add1()&#123; SqlAccess sql = new SqlAccess(); string tablename = &quot;auther&quot;; string authername = authernameinput.text; string authersex = authersexinput.text; string birth = birthinput.text; string area = areainput.text; string country = countryinput.text; string[] datavalues = new string[] &#123; authername, authersex, birth, area, country &#125;; if (authername != &quot;&quot;) &#123; ds = sql.Additem(tablename, datavalues); chenggong.SetActive(true); &#125; if (ds == null) &#123; shibai.SetActive(true); &#125;&#125; 6、修改界面Ⅰ、界面绘制及功能介绍 用户通过输入书籍名称对要修改的书籍进行查找 查找完成后可以对书籍信息进行修改，修改完成后点击 修改 按钮 再点击确认，即可修改成功 Ⅱ、功能实现创建 AlterCanvas.cs 脚本 （1）引入命名空间123456using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using System.Data;using System.Timers; （2）变量及组件的初始化123456789101112131415161718192021222324252627public GameObject confcanvas;public GameObject confcanvas1;public InputField input_bookname;public Text showtext;public InputField nameinput;public InputField autherinput;public InputField producerinput;public InputField ageinput;public InputField tanslaterinput;public InputField starinput;public InputField borrowinput;public Button querybtn;public Button alterbtn;public Button shanchubtn;public Button quxiao_btn;public Button queren_btn;public Button quxiao_btn1;public Button queren_btn1;private Color colorOrgion = new Color(0, 0, 0, 1);//默认为黑色private float Alpha = 1.0f;private bool isbeclikck = false;Timer timer = new Timer(2000);//延迟2秒 （3）组件绑定及变量初始化1234567891011121314151617181920212223void Start()&#123; querybtn.onClick.AddListener(chaxun); alterbtn.onClick.AddListener(xianshi); quxiao_btn.onClick.AddListener(quxiao); queren_btn.onClick.AddListener(queren); shanchubtn.onClick.AddListener(xianshi1); quxiao_btn1.onClick.AddListener(quxiao1); queren_btn1.onClick.AddListener(queren1); showtext.color = new Color(0, 0, 0, 0);//默认不显示 timer.Elapsed += (object sender, ElapsedEventArgs e) =&gt; &#123; isbeclikck = true; &#125;; timer.AutoReset = false; //如果 System.Timers.Timer 应在每次间隔结束时引发 System.Timers.Timer.Elapsed 事件，则为 true；如果它仅在间隔第一次结束后引发一次，可以新建一颗控制台应用，然后F12跟进去查看详情，这是我复制粘贴的， timer.Enabled = true;// 如果 System.Timers.Timer 应引发 System.Timers.Timer.Elapsed 事件，则为 true；&#125; （4）依次实现各个按钮的功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private void Update()&#123; if (isbeclikck) &#123; Alpha = Alpha - (Time.deltaTime);//通过修改阿尔法值来设置显示或隐藏 colorOrgion.a = Alpha; showtext.color = colorOrgion; &#125; if (colorOrgion.a &lt;= 0)//如果阿尔法小于0就代表文字完全消失了 &#123; isbeclikck = false; &#125;&#125;void chaxun()&#123; SqlAccess sql = new SqlAccess(); string[] inputitem = new string[7]; string[] items = &#123; &quot;*&quot; &#125;; string tablename = &quot;books&quot;; string bookname = input_bookname.text; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; Debug.Log(row[column] + &quot;aa&quot;); str += row[column] + &quot; &quot;; &#125; Debug.Log(str); string[] strSplit = str.Split(); foreach (var item in strSplit) &#123; Debug.Log(item + &quot; &quot;); &#125; nameinput.text = strSplit[0]; autherinput.text = strSplit[1]; producerinput.text = strSplit[2]; ageinput.text = strSplit[3]; tanslaterinput.text = strSplit[4]; starinput.text = strSplit[5]; borrowinput.text = strSplit[6]; &#125; &#125; &#125;void queren()&#123; if (input_bookname.text != &quot;&quot;) &#123; SqlAccess sql = new SqlAccess(); string tablename = &quot;books&quot;; string deletename = input_bookname.text; DataSet ds1 = sql.Delete(tablename, deletename); string bookname = nameinput.text; string auther = autherinput.text; string producer = producerinput.text; string age = ageinput.text; string translate = tanslaterinput.text; string star = starinput.text; string borrowed = borrowinput.text; string[] datavalues = new string[] &#123; bookname, auther, producer, age, translate, star, borrowed &#125;; DataSet ds2 = sql.Additem(tablename, datavalues); confcanvas.SetActive(false); showtext.color = new Color(0, 0, 1, 1);//只要点击按钮就会把文字的阿尔法值设置为1 Alpha = 1; colorOrgion.a = 1.0f; timer.Start(); //开始计时，2秒之后执行Timer_Elapsed方法； &#125;&#125;void queren1()&#123; if (input_bookname.text != &quot;&quot;) &#123; SqlAccess sql = new SqlAccess(); string tablename = &quot;books&quot;; string deletename = input_bookname.text; DataSet ds1 = sql.Delete(tablename, deletename); confcanvas1.SetActive(false); Alpha = 1; colorOrgion.a = 1.0f; timer.Start(); //开始计时，2秒之后执行Timer_Elapsed方法； &#125;&#125;void xianshi()&#123; confcanvas.SetActive(true);&#125;void quxiao()&#123; confcanvas.SetActive(false);&#125;void xianshi1()&#123; confcanvas1.SetActive(true);&#125;void quxiao1()&#123; confcanvas1.SetActive(false);&#125;private void Timer_Elapsed(object sender, ElapsedEventArgs e)&#123; isbeclikck = true;&#125; 7、图表界面Ⅰ、界面绘制及功能介绍 该界面有一个饼状图和一个柱状图 上图为初始化状态 程序运行后 这两个图表会显示全部书籍的豆瓣评分分布状态 将鼠标移到饼状图的各个分布上，还会实现突出显示功能 点击饼状图的副标题，可选择是否隐藏该分部 【注】底部柱状图x轴的乱码属于编译编码问题，在程序打包后即可解决 Ⅱ、功能实现图表绘制调用了Unity内置的动画状态机实现 图表数据的更新赋值调用如下函数实现，该函数在 MainCanva.cs 中被调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void xiugai()&#123; int a = 0; int b = 0; int c = 0; selcanva.gameObject.SetActive(false); addcanva.gameObject.SetActive(false); altercanva.gameObject.SetActive(false); showchartcanva.gameObject.SetActive(true); SqlAccess sql = new SqlAccess(); string[] items = &#123; &quot;star&quot; &#125;; string tablename = &quot;books&quot;; string bookname = null; DataSet ds = sql.SelectWhere(tablename, items, bookname); if (ds != null) &#123; DataTable table = ds.Tables[0]; foreach (DataRow row in table.Rows) &#123; string str = &quot;&quot;; foreach (DataColumn column in table.Columns) &#123; str += row[column]; float num = float.Parse(str); if (num &gt;= 9.0f) a++; else if (num &lt;= 8.0f) c++; else b++; //stars.Add(float.Parse(str)); &#125; &#125; &#125; chart.UpdateData(0, 0, a); chart.UpdateData(0, 1, b); chart.UpdateData(0, 2, c); var yAxis = barchart.GetChartComponent&lt;YAxis&gt;(); yAxis.minMaxType = Axis.AxisMinMaxType.Default; barchart.RemoveData(); serie = barchart.AddSerie&lt;Bar&gt;(&quot;Star&quot;); barchart.AddXAxisData(&quot;小于8.0&quot;); barchart.AddData(0, c); barchart.AddXAxisData(&quot;8.0-9.0&quot;); barchart.AddData(0, b); barchart.AddXAxisData(&quot;大于9.0&quot; ); barchart.AddData(0, a);&#125; 五、实验总结及心得（略）","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"传送门特效及实现","slug":"奇异博士传送门","date":"2022-07-27T09:47:18.094Z","updated":"2022-07-26T03:54:50.293Z","comments":true,"path":"2022/07/27/奇异博士传送门/","link":"","permalink":"http://example.com/2022/07/27/%E5%A5%87%E5%BC%82%E5%8D%9A%E5%A3%AB%E4%BC%A0%E9%80%81%E9%97%A8/","excerpt":"一、传送门特效1、使用组件采用Unity内置渲染管线中的Particle System制作 2、实现思路（1）首先创建四个圆球用于特效的定位，并且采用动画效果使其分散并旋转。","text":"一、传送门特效1、使用组件采用Unity内置渲染管线中的Particle System制作 2、实现思路（1）首先创建四个圆球用于特效的定位，并且采用动画效果使其分散并旋转。 （2）新建一个Particle System，将其作为上述小球的子物体，将shape改为box，并修改颜色，添加自定义材质。 （3）再新建一个Particle System，将其作为上述小球的子物体，修改同上，并且设置Start Delay、Start Speed等，增加粒子量与Emission，使其呈现出喷散效果。 （4）将 (2) (3) 组合，并复制一份到另一个小球上。 （5）再次新建Particle System，将shape改为Circle，适当减少粒子量 ，同时调整Start Delay、Start Lifetime、Start Speed与Velocity over LifeTime，添加碰撞效果，增加半径，并改为从边缘发射，得到如下效果。 （6）添加底部倒影。将Emission的粒子量减小到5，Start Speed设为0，进行旋转缩放，使其贴近地面 （7）制作两侧溅射效果。将（5）处效果复制一份，对圆进行扇形裁减，扩大其 Velocity of LifeTime，使其溅射距离加大，同时添加与地面的碰撞效果。 （8）将（7）处效果复制一份，旋转180置于另一侧，将上述效果组合起来，开启后处理（Bloom效果）。同时将一开始创建的四个小球利用起来，为其添加HDR颜色，伪装成高光闪烁部分。 3、分析共计使用了8个Particle System，总粒子数在10000左右。材质贴图为自定义制作。 可以通过不同的材质贴图对粒子数进行修改，若将图中白色部分拉长，可适当减少粒子数量。 经过测试，粒子将会显得十分细长，且颜色不好控制，即使将bloom效果开的很低，也难以分辨。 二、具体传送效果1、组件使用情况玩家：一个人物和摄像机移动的控制脚本 传送门：一个总控制脚本，两个传送脚本 Shader：使用屏幕空间的坐标，材质附加在传送门上 传送门：一个Cylinder模型，将其压缩，模拟一个圆形面。 2、实现思路场景中共有三个摄像头(两个传送门)。一个玩家主摄像头，两个传送门摄像头PortalCamA 和 PortalCamB，首先新建两个Render Texture 作为两个传送门所用的摄像头的Target Texture，将PortalCamA 渲染出的Render Texture添加到传送门B上，作为主纹理。 配合上述Shader中的裁剪效果 1234567// verto.vertex = UnityObjectToClipPos(v.vertex);o.screenPos = ComputeScreenPos(o.vertex);..........................//frag float2 uv = i.screenPos.xy / i.screenPos.w;fixed4 portalCol = tex2D(_MainTex, uv); 传送门B中显示的便是PortalCamA摄像机所观察到的画面。 对另一个传送门采用同样的设置。 根据向量加减的原理，可以同玩家相对于传送门A的位置 和 传送门B的位置求出PortalCamB的位置，此时PortalCamB的观察图像就相当于玩家在另一个场景的观察图像。 12345678Yangle = player.transform.eulerAngles.y;Xangle = playerCam.transform.eulerAngles.x;portalCamB.transform.position = DoorB.position + player.position - DoorA.position;portalCamB.transform.localRotation = Quaternion.Euler(Xangle,Yangle,0);portalCamA.transform.position = DoorA.position + player.position - DoorB.position;portalCamA.transform.localRotation = Quaternion.Euler(Xangle,Yangle,0); 为传送门添加一个碰撞体，当玩家进入到传送门A时，触发传送效果，将此时 PortalCamB 的位置和旋转角度赋值给玩家及摄像头，即可实现玩家位置的传送效果。 此处添加了一个判断，用于对摄像机进行渲染层级的裁剪，避免视角重叠情况。 12345678910// camera.cullingMask &amp;= ~(1 &lt;&lt; x); // 关闭层xplayerCam.cullingMask &amp;= ~(1 &lt;&lt; PortalLayer);..............................................................MyPortal01.transflag = MyPortal01.transflag + 1;if(MyPortal01.transflag == 3)&#123; // camera.cullingMask |= (1 &lt;&lt; x); // 打开层x playerCam.cullingMask |= (1 &lt;&lt; PortalLayer);&#125; 踩坑点：1、玩家控制脚本使用了Character Controller组件导致 1other.transform.position = transPos; 赋值后不起作用，需要在cc. move() 前面添加如下代码 1Physics.autoSyncTransforms = true; 2、在使用碰撞体触发传送时，进入第一个传送门触发一次OnTriggerEnter()，然后传送到第二个传送门，触发一次来自第一个传送门的OnTriggerExit() 和来自第二个传送门的OnTriggerEnter()。","categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"}]},{"title":"《Deep Learning for Rendering》阅读笔记","slug":"DL for Render阅读笔记","date":"2022-07-27T09:47:18.087Z","updated":"2022-07-26T04:11:49.393Z","comments":true,"path":"2022/07/27/DL for Render阅读笔记/","link":"","permalink":"http://example.com/2022/07/27/DL%20for%20Render%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"中科大第九届《计算机图形学前沿》暑期课程 主讲人：过洁 原视频地址：https://www.bilibili.com/video/BV1Kf4y157WW?p=17&amp;vd_source=e4b21da575ef85d87ce1b8e9f64ca190","text":"中科大第九届《计算机图形学前沿》暑期课程 主讲人：过洁 原视频地址：https://www.bilibili.com/video/BV1Kf4y157WW?p=17&amp;vd_source=e4b21da575ef85d87ce1b8e9f64ca190 一、渲染 场景里的几何、材质、光照等通过一个渲染器，生成一张图片 几何三角网格(传统)、体素、点云 三角网格在复杂场景中数据量巨大 材质材质 ≠ 纹理 描述 光线打到物体上后经过反射、折射等各种交互，出来后的形态各种各样 光源次生光线、递归迭代 渲染中的某些场景元素(信号)的特点 高纬度（High dimensionality） 奇点 （Singularity） 多模态 （Multi-modality）–网格、体素、点云 数据量巨大 （Huge data size） 导致的问题：渲染很困难 二、深度学习中的渲染深度学习中的功能 处理高纬度和多模态的数据（高纬度可以压缩、多模态可以多模态融合） 神经网络比某些人手写的公式更好、更快、更鲁棒 可以在很复杂的问题中探索 low-rank 特征 深度学习在渲染中的两个角色1、深度学习可以学习某种表征来对复杂场景元素进行编码 对几何材质光源进行抽象 可在 forward rendering 和 inverse rendering 中使用 2、学习一个domain到其他domain 的映射函数 图片到图片 传统方法是从手工推出的函数 第一个角色学习一个 表示（representation） 可学习对象：几何、材质、光源、场景 （1）几何用神经网络表示各种各样的几何体 在场景中表示几何： 多视角图片 Signed distance function （SDF）三维重建 稠密体素 稀疏体素 点云 网格 …… 用网络去处理 mesh 的很少 （2）材质用神经网络去表示材质 材质可以抽象成一个函数，包含16个变量（入射、出射光方向、时间） 用经验模型简化材质 直接采集： 密集采样， 移动相机光源采样、 将数据保存在一个table里面。 耗内存、速度慢 措施：压缩、降维 用深度学习去压缩材质 DeepBRDF ： latent space ：潜在空间、隐空间 参考： https://zhuanlan.zhihu.com/p/369946876 潜在空间只是压缩数据的表示，其中相似的数据点在空间上更靠近在一起。 潜在空间对于学习数据功能和查找更简单的数据表示形式以进行分析很有用。 我们可以通过分析潜在空间中的数据（通过流形，聚类等）来了解数据点之间的模式或结构相似性。 我们可以在潜在空间内插值数据，并使用模型的解码器来“生成”数据样本。 我们可以使用t-SNE和LLE之类的算法来可视化潜在空间，该算法将我们的潜在空间表示形式转换为2D或3D。 将 BRDF Slice作为输入 BRDF 不考虑材质的表面变化，若考虑表面变化还有一些光照效果等，我们采用 BTF BTF： Bidirectional Texture Function 对 SVBRDF 进行压缩 用神经网络去压缩材质空间，这个工作远没有结束 【三维体素型材质】：玉石、烟雾、半透明物体 借鉴风格迁移 只是风格相似，不一定是完全match 对于任何一张图片，可以抽取其风格，然后迁移到三维物体上 （3）用神经网络表示光源 环境光也是一种高维信号，同样的思想，采用神经网络去压缩，压缩形成的latent space并不是用于渲染，而是用于光照估计。 先用神经网路抽取一个室外全景图的latent space，可以用于光照估计，输入一张图，去预测光照，先预测latent code，然后再用decode去恢复这张环境图。 应用：把虚拟物体插入到真实环境下 这项工作在深度学习里有个非常重要的思想：disentanglement 刚才讲到是室外光，那么室内光是否也可以用auto-encode、GAN等进行压缩？ 答案是不行，室内光过于复杂，难以压缩。 该项工作把光源压缩到一个神经网络上 （4）场景那么是否可以直接对整个场景，不分几何材质光照，进行压缩？ Neural scene 限制：容易丢失细节 第二个角色： Mapping 映射从一个 domain 到另一个 domain 去噪 超分 直接光—间接光 渲染图片—材质贴图 （1）去噪 漫反射-镜面反射的分解 G-buffer 无限的训练样本（理论上） 解调 Demodulation （图象 &#x2F; albedo） 在无监督去噪中，loss是关键 （2）超分典例：DLSS、Neual SS （3）从直接光照预测间接光照 该方向的研究较少 直接光照很快，间接光照很慢 （4）从渲染图片出发，反推场景元素 从单张图片恢复 各种光照贴图，对于光泽效果的呈现尤为重要","categories":[{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"CG","slug":"CG","permalink":"http://example.com/tags/CG/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-27T09:40:11.532Z","updated":"2022-07-26T01:51:28.452Z","comments":true,"path":"2022/07/27/hello-world/","link":"","permalink":"http://example.com/2022/07/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/categories/Unity/"},{"name":"Shader学习","slug":"Shader学习","permalink":"http://example.com/categories/Shader%E5%AD%A6%E4%B9%A0/"},{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"},{"name":"CG","slug":"CG","permalink":"http://example.com/categories/CG/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"},{"name":"Shader","slug":"Shader","permalink":"http://example.com/tags/Shader/"},{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"CG","slug":"CG","permalink":"http://example.com/tags/CG/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]}